{"id": "-304__________NO_SQL_docx#1", "doc_id": "-304__________NO_SQL_docx", "text": "Міністерство освіти та науки України\nДержавний вищий навчальний заклад «Київський національний економічний університет ім. Вадима Гетьмана»\n\nКафедра інформаційних систем в економіці\n\n\n\n\nДисципліна «Організація баз даних NoSQL»\n\n\n\nРЕФЕРАТ \nна тему: \n“ 15. Агрегування в запитах MongoDB” \n\n\n\n\n\nПідготував:\nстудент 3 курсу, групи ІН-304\nспеціальності \n“Комп’ютерні науки”\n\n                                                                                                            Прийняв:\n проф. Ситник Н. В. Київ - 2022\nЗМІСТ\nВСТУП\t2\n1\tРозуміння агрегації та її типи\t3\n2\tПерший крок – Підготовка текстових даних\t5\n3\tДругий крок – Використання стадії $match агрегації\t7\n4\tТретій крок – Використання стадії $sort агрегації\t10\n5\tЧетвертий крок – Використання стадії $group агрегації\t13\n6\tП’ятий крок – Використання стадії $project агрегації\t18\n7\tСкладання всіх етапів разом\t21\nВИСНОВКИ\t25\nПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ\t26\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВСТУП\nВ цьому рефераті на тему «Агрегування в запитах MongoDB» ми розглянемо конвеєри агрегації, функції MongoDB для багатоетапної обробки документів, включаючи фільтрацію, сортування, узагальнення та трансформацію.", "type": "text", "meta": {"page": null, "order": 1, "ingested_at": "2025-11-09T22:28:27.223989"}}
{"id": "-304__________NO_SQL_docx#2", "doc_id": "-304__________NO_SQL_docx", "text": "розглянемо конвеєри агрегації, функції MongoDB для багатоетапної обробки документів, включаючи фільтрацію, сортування, узагальнення та трансформацію. Використаємо та обґрунтуємо етапи $match, $sort, $group, і $project агрегації один за одним і разом, з наведенням прикладів запитів, обробивши вхідні документи для представлення зведених даних. Також, ознайомимося з обчислювальними полями та операторами накопичувачів, щоб знаходити максимуми та суми з груп документів. MongoDB — це система керування базами даних, яка дозволяє зберігати великі обсяги даних у документах, які зберігаються у великих структурах, відомих як колекції. Ви можете запускати запити до колекцій, щоб отримати підмножину документів, які відповідають заданим умовам, але механізм запитів MongoDB не дозволяє групувати або перетворювати повернуті дані. Це означає, що ваші можливості для виконання значимого аналізу даних лише за допомогою механізму запитів MongoDB обмежені. Як і в багатьох інших системах баз даних, MongoDB дозволяє виконувати різноманітні операції агрегації.", "type": "text", "meta": {"page": null, "order": 2, "ingested_at": "2025-11-09T22:28:27.224002"}}
{"id": "-304__________NO_SQL_docx#3", "doc_id": "-304__________NO_SQL_docx", "text": "а допомогою механізму запитів MongoDB обмежені. Як і в багатьох інших системах баз даних, MongoDB дозволяє виконувати різноманітні операції агрегації. Вони дозволяють обробляти записи даних різними способами, наприклад групувати дані, сортувати дані в певному порядку або реструктуризувати повернуті документи, а також фільтрувати дані, як це можна зробити за допомогою запиту. MongoDB забезпечує операції агрегації через конвеєри агрегації — серію операцій, які послідовно обробляють документи даних. У цьому підручнику ви на прикладі дізнаєтеся, як використовувати найпоширеніші функції конвеєрів агрегації. Ви будете фільтрувати, сортувати, групувати та трансформувати документи, а потім використовувати всі ці функції разом для створення багатоетапної обробки. Розуміння агрегації та її типи\nПрацюючи з системою керування базами даних, щоразу, коли ви хочете отримати дані з бази даних, ви повинні виконати операцію, відому як запит. Однак запити повертають лише ті дані, які вже існують у базі даних. Щоб проаналізувати ваші дані, щоб знайти закономірності чи іншу інформацію про дані, а не самі дані, вам часто доведеться виконувати іншу операцію, відому як агрегація.", "type": "text", "meta": {"page": null, "order": 3, "ingested_at": "2025-11-09T22:28:27.224005"}}
{"id": "-304__________NO_SQL_docx#4", "doc_id": "-304__________NO_SQL_docx", "text": "ваші дані, щоб знайти закономірності чи іншу інформацію про дані, а не самі дані, вам часто доведеться виконувати іншу операцію, відому як агрегація. Агрегації групують дані з кількох джерел, а потім обробляють ці дані певним чином, щоб повернути єдиний результат. У реляційній базі даних система керування базою даних зазвичай отримує дані з кількох рядків однієї таблиці для виконання агрегатної функції. Однак у базі даних, орієнтованій на документи, такій як MongoDB, база даних отримуватиме дані з кількох документів в одній колекції. MongoDB дає змогу виконувати операції агрегації за допомогою механізму, що називається конвеєрами агрегації. Вони побудовані як послідовний ряд декларативних операцій обробки даних, відомих як етапи. Рис. 1 – Тут дані передаються в кожному конвеєрі, який фільтрує, групує та сортує дані та повертає результат\n Кожен етап перевіряє та перетворює документи, коли вони проходять через конвеєр, надаючи перетворені результати на наступні етапи для подальшої обробки.", "type": "text", "meta": {"page": null, "order": 4, "ingested_at": "2025-11-09T22:28:27.224008"}}
{"id": "-304__________NO_SQL_docx#5", "doc_id": "-304__________NO_SQL_docx", "text": "жен етап перевіряє та перетворює документи, коли вони проходять через конвеєр, надаючи перетворені результати на наступні етапи для подальшої обробки. Документи з вибраної колекції надходять у конвеєр і проходять кожен етап, де вихідні дані, що надходять з одного етапу, утворюють вхідні дані для наступного, а кінцевий результат надходить у кінці конвеєра. Це може допомогти уявити цей процес як овочі, що проходять через конвеєр на кухні ресторану. У цій аналогії овочі проходять через набір станцій, кожна з яких відповідає за одну дію: миття, очищення від шкірки, нарізання, варіння та розміщення. Подібним чином дані, що надходять у конвеєр агрегації, повинні пройти кілька етапів, кожен з яких відповідає за певну операцію.", "type": "text", "meta": {"page": null, "order": 5, "ingested_at": "2025-11-09T22:28:27.224010"}}
{"id": "-304__________NO_SQL_docx#6", "doc_id": "-304__________NO_SQL_docx", "text": "варіння та розміщення. Подібним чином дані, що надходять у конвеєр агрегації, повинні пройти кілька етапів, кожен з яких відповідає за певну операцію. Етапи можуть виконувати операції з такими даними, як:\nфільтрація: це нагадує запити, де список документів звужується за допомогою набору критеріїв;\nсортування: ви можете змінити порядок документів на основі вибраного поля;\nтрансформація: можливість змінювати структуру документів означає, що ви можете видалити або перейменувати певні поля, або, можливо, перейменувати чи згрупувати поля у вбудованому документі для зручності читання;\nгрупування: ви також можете обробити кілька документів разом, щоб сформувати зведений результат. На стадіях конвеєра не потрібно створювати таку саму кількість документів, яку вони отримують. Продовжуючи нашу аналогію з кухнею, уявіть станцію подрібнення, яка бере цілі овочі та передає їх у вигляді кількох скибочок, або станцію контролю якості, яка відхиляє овочі з дефектами та передає на наступну станцію лише кілька здорових. Подібним чином етапи можуть генерувати нові документи або відфільтровувати існуючі з колекції, яка була введена на початку конвеєра.", "type": "text", "meta": {"page": null, "order": 6, "ingested_at": "2025-11-09T22:28:27.224013"}}
{"id": "-304__________NO_SQL_docx#7", "doc_id": "-304__________NO_SQL_docx", "text": "кілька здорових. Подібним чином етапи можуть генерувати нові документи або відфільтровувати існуючі з колекції, яка була введена на початку конвеєра. Крім того, один і той самий етап може з’являтися більше одного разу в конвеєрі агрегації, застосовуючи кілька операцій одна за одною. У наступних кроках ви підготуєте тестову базу даних, яка буде служити прикладом набору даних. Потім ви дізнаєтеся, як окремо використовувати кілька найпоширеніших етапів конвеєра агрегації. Далі, ви об’єднаєте ці етапи, щоб сформувати повний приклад конвеєра. Перший крок – Підготовка текстових даних\nЩоб дізнатися, як працюють конвеєри агрегації та як ними користуватися, у цьому кроці описано, як відкрити оболонку MongoDB для підключення до локально встановленого екземпляра MongoDB. Тут також пояснюється, як створити колекцію зразків і вставити в неї кілька зразків документів. Щоб зрозуміти, як працюють конвеєри агрегації, знадобиться набір документів із кількома полями різних типів, які можна різними способами фільтрувати, сортувати, групувати та підсумовувати. Рис. 2 – Зразок набору документів із різними типами полів\n\tЦей документ містить таку інформацію:\nname: назва міста.", "type": "text", "meta": {"page": null, "order": 7, "ingested_at": "2025-11-09T22:28:27.224015"}}
{"id": "-304__________NO_SQL_docx#8", "doc_id": "-304__________NO_SQL_docx", "text": "увати, групувати та підсумовувати. Рис. 2 – Зразок набору документів із різними типами полів\n\tЦей документ містить таку інформацію:\nname: назва міста. country: країна, де розташоване місто. continent: континент, на якому розташоване місто. population: населення міста, млн. чол. Далі, потрібно наступний insertMany()метод в оболонці MongoDB, щоб одночасно створити колекцію з іменем cities і вставити в неї двадцять зразків документів. Ці документи описують двадцятку найбільш густонаселених міст світу:\n\nРис. 3 – Створення колекції з іменем cities і встановлення в неї двадцять зразків документів\nМаючи зразки даних на місці, можемо перейти до наступного кроку, щоб дізнатися, як створити конвеєр агрегації за допомогою $match. Другий крок – Використання стадії $match агрегації\nЩоб створити конвеєр агрегації, можна  використовувати aggregate() метод MongoDB. Цей метод використовує синтаксис, який досить схожий на find() метод, який використовується для запиту даних у колекції, але aggregate() приймає одне або кілька імен етапів як аргументи. Цей крок зосереджений на тому, як використовувати $match етап агрегації.", "type": "text", "meta": {"page": null, "order": 8, "ingested_at": "2025-11-09T22:28:27.224017"}}
{"id": "-304__________NO_SQL_docx#9", "doc_id": "-304__________NO_SQL_docx", "text": "у колекції, але aggregate() приймає одне або кілька імен етапів як аргументи. Цей крок зосереджений на тому, як використовувати $match етап агрегації. Незалежно від того, чи бажаєте ви виконати легку обробку структури документа, узагальнити чи складні перетворення, зазвичай ви захочете зосередити свій аналіз лише на виборі документів, які відповідають певним критеріям. $match може використовуватися для звуження списку документів на будь-якому конкретному етапі конвеєра, а також для забезпечення того, що всі наступні операції будуть виконуватися з обмеженим списком записів. Як приклад, виконайте наступну операцію. Це створить конвеєр агрегації за допомогою одного $match етапу без будь-якого конкретного запиту фільтрації: \n\nРис. 4 – Створення $match етапу без будь-якого конкретного запиту фільтрації\nМетод aggregate(), який виконується в cities колекції, наказує MongoDB запустити конвеєр агрегації, який передається як аргумент методу. Оскільки конвеєри агрегації є багатоетапними процесами, аргументом є список етапів, тому використання квадратних дужок [], що позначає масив із кількох елементів. Кожен елемент всередині цього масиву є об'єктом, що описує етап обробки.", "type": "text", "meta": {"page": null, "order": 9, "ingested_at": "2025-11-09T22:28:27.224020"}}
{"id": "-304__________NO_SQL_docx#10", "doc_id": "-304__________NO_SQL_docx", "text": "ому використання квадратних дужок [], що позначає масив із кількох елементів. Кожен елемент всередині цього масиву є об'єктом, що описує етап обробки. Оператор тут записується як { $match: { } }. У цьому документі, що описує етап обробки, ключ $match відноситься до типу етапу, а значення { }описує його параметри. У нашому прикладі $match етап використовує порожній документ запиту як параметр і є єдиним етапом у всьому конвеєрі обробки. $match звужує перелік документів з колекції. Без застосованих параметрів фільтрації MongoDB поверне список усіх міст із колекції:\n\nРис. 5 – Приклад застусування $match, без застосованих параметрів фільтрації\nДалі aggregate() знову запустіть метод, але цього разу додайте документ запиту як параметр до $match етапу. Тут можна використовувати будь-який дійсний документ запиту. Також, можна розглядати використання $match етапу як еквівалент запиту до колекції find(). Найбільша відмінність полягає в тому, що $match його можна використовувати кілька разів у конвеєрі агрегації, дозволяючи запитувати документи, які вже були оброблені та перетворені раніше в конвеєрі. Запускаємо наступний aggregate() метод.", "type": "text", "meta": {"page": null, "order": 10, "ingested_at": "2025-11-09T22:28:27.224022"}}
{"id": "-304__________NO_SQL_docx#11", "doc_id": "-304__________NO_SQL_docx", "text": "конвеєрі агрегації, дозволяючи запитувати документи, які вже були оброблені та перетворені раніше в конвеєрі. Запускаємо наступний aggregate() метод. Цей приклад містить $match етап вибору лише міст із Північної Америки:\n\nРис. 6 – Приклад застусування $match, лише з одним параметром\n\tЦього разу { \"continent\": \"North America\" }документ запиту з’являється як параметр $match. Отже, MongoDB повертає два міста з Північної Америки:\n\nРис. 7 – Приклад застусування $match, лише з одним параметром\nЦя команда повертає той самий результат, що й наступна, яка замість цього використовує find() метод для запиту до бази даних:\n\nРис. 8 – Приклад без застусування $match\n\nПопередній aggregate() метод повертає лише два міста, тому експериментувати не варто. Щоб отримати більше результатів, потрібно змінити цю команду, щоб вона повертала міста Північної Америки та Азії:\n\nРис. 9 – Приклад застусування $match\nТакож, синтаксис документа запиту знову ідентичний тому, як ви отримуєте ті самі дані за допомогою find() методу. Цього разу MongoDB повертає 14 різних міст:\n\nРис.", "type": "text", "meta": {"page": null, "order": 11, "ingested_at": "2025-11-09T22:28:27.224025"}}
{"id": "-304__________NO_SQL_docx#12", "doc_id": "-304__________NO_SQL_docx", "text": "сис документа запиту знову ідентичний тому, як ви отримуєте ті самі дані за допомогою find() методу. Цього разу MongoDB повертає 14 різних міст:\n\nРис. 10 – Приклад застусування $match\nВ даному розділі дізналися, як виконувати конвеєр агрегації та використовувати $match етап для звуження документів колекції. Третій крок – Використання стадії $sort агрегації \nЦей $match етап корисний для звуження списку документів, які переходять до наступного етапу агрегування. Однак $match нічого не змінює чи перетворює дані, коли вони проходять через конвеєр. Під час запиту до бази даних зазвичай очікується певний порядок під час отримання результатів. Використовуючи стандартний механізм запиту, ви можно вказати порядок документів, додавши sort() метод у кінець find() запиту. Наприклад, щоб отримати кожне місто в колекції та відсортувати їх у порядку спадання за населенням, ви можете виконати таку операцію:\n\nРис. 11 – Приклад застусування sort()\nMongoDB поверне кожне місто, починаючи з Токіо, потім Делі, Сеул і так далі:\n\nРис. 12 – Приклад застусування sort()\nТакож, можна сортувати документи в конвеєрі агрегації, включивши $sort етап. Щоб проілюструвати це, запустіть наступний aggregate() метод.", "type": "text", "meta": {"page": null, "order": 12, "ingested_at": "2025-11-09T22:28:27.224027"}}
{"id": "-304__________NO_SQL_docx#13", "doc_id": "-304__________NO_SQL_docx", "text": "ання sort()\nТакож, можна сортувати документи в конвеєрі агрегації, включивши $sort етап. Щоб проілюструвати це, запустіть наступний aggregate() метод. Синтаксис подібний до попередніх прикладів, де використовувався $match етап:\n\nРис. 13 – Приклад сортування документів в конвеєрі агрегації, включивши $sort\nЗнову ж таки, список етапів, що використовуються в конвеєрі агрегації, передається як масив визначень етапів між парою квадратних дужок ( []). Визначення етапу в цьому прикладі включає лише один $sort етап як ключ, його значенням є документ, що містить параметри сортування. Тут можна використовувати будь-який дійсний документ сортування. MongoDB поверне той самий набір результатів, що й попередня find() операція, оскільки використання конвеєра агрегації лише з етапом сортування еквівалентно стандартному запиту із застосуванням порядку сортування:\n\nРис. 14 – Приклад застусування без sort()\nЯкщо отримати міста лише з Північної Америки, відсортовані за кількістю населення в порядку зростання.", "type": "text", "meta": {"page": null, "order": 13, "ingested_at": "2025-11-09T22:28:27.224029"}}
{"id": "-304__________NO_SQL_docx#14", "doc_id": "-304__________NO_SQL_docx", "text": "ння:\n\nРис. 14 – Приклад застусування без sort()\nЯкщо отримати міста лише з Північної Америки, відсортовані за кількістю населення в порядку зростання. Для цього ви можете застосувати два етапи обробки один за одним: перший, щоб звузити набір результатів за допомогою $match етапу фільтрації, а потім другий, щоб застосувати необхідне впорядкування за допомогою $sort етапу:\n\nРис. 15 – Приклад застусування $sort та $match разом\nНа два окремих етапи в синтаксисі команди, розділених комою в масиві етапів. Цього разу MongoDB поверне документи, що представляють Нью-Йорк і Мехіко, єдині два міста Північної Америки, починаючи з Нью-Йорка, оскільки він має меншу кількість населення:\n\nРис. 16 – Приклад застусування $sort та $match разом\nЩоб отримати ці результати, MongoDB спочатку пропустив колекцію документів через $match етап, відфільтрував документи за критеріями запиту, а потім переслав результати на наступний етап у рядку, відповідальний за сортування результатів.", "type": "text", "meta": {"page": null, "order": 14, "ingested_at": "2025-11-09T22:28:27.224032"}}
{"id": "-304__________NO_SQL_docx#15", "doc_id": "-304__________NO_SQL_docx", "text": "h етап, відфільтрував документи за критеріями запиту, а потім переслав результати на наступний етап у рядку, відповідальний за сортування результатів. Подібно до $match етапу, $sort може з’являтися кілька разів у конвеєрі агрегації та може сортувати документи за будь-яким полем, яке може знадобитися, включно з полями, які з’являтимуться в структурі документа лише під час агрегації. Четвертий крок – Використання стадії $group агрегації \nЕтап $group агрегування відповідає за групування та узагальнення документів. Він приймає кілька документів і розподіляє їх у кілька окремих пакетів на основі групування значень виразів і виводить окремий документ для кожного окремого пакета. Вихідні документи містять інформацію про групу та можуть містити додаткові обчислені поля, наприклад суми або середні значення в списку документів із групи. Для ілюстрації запустіть наступний aggregate() метод. Це включає в себе $group етап, який групує отримані документи за континентом, на якому розташоване кожне місто:\n\nРис. 17 – Приклад застусування $group \nУ MongoDB кожен документ повинен мати _id поле, яке буде використовуватися як первинний ключ.", "type": "text", "meta": {"page": null, "order": 15, "ingested_at": "2025-11-09T22:28:27.224034"}}
{"id": "-304__________NO_SQL_docx#16", "doc_id": "-304__________NO_SQL_docx", "text": "ане кожне місто:\n\nРис. 17 – Приклад застусування $group \nУ MongoDB кожен документ повинен мати _id поле, яке буде використовуватися як первинний ключ. З кроку 1, що insertMany() метод, який використовувався для створення колекції зразків, не включав це поле в жодні зразки документів. Це тому, що MongoDB автоматично створює це поле та генерує унікальні ідентифікаційні номери у формі ObjectId полів. Однак для $group етапів у конвеєрі агрегації потрібно вказати _idполе з дійсним виразом. Цей aggregate() метод, однак, визначає _id значення; а саме, кожне значення, знайдене в continent полях кожного документа в cities колекції. Кожного разу, коли посилатися на значення поля в конвеєрі агрегації, подібному до цього, ви повинні поставити перед назвою поля знак долара ($). У MongoDB це називається шляхом до поля, оскільки він спрямовує операцію до відповідного поля, де можна знайти значення для використання на етапі конвеєра. У цьому прикладі \"$continent\" вказує MongoDB взяти continent поле з вихідного документа та використати його значення для створення значення виразу в конвеєрі агрегації. MongoDB виведе окремий документ для кожного унікального значення цього виразу групування:\n\nРис.", "type": "text", "meta": {"page": null, "order": 16, "ingested_at": "2025-11-09T22:28:27.224036"}}
{"id": "-304__________NO_SQL_docx#17", "doc_id": "-304__________NO_SQL_docx", "text": "ня для створення значення виразу в конвеєрі агрегації. MongoDB виведе окремий документ для кожного унікального значення цього виразу групування:\n\nРис. 18 – Приклад застусування $group\nУ цьому прикладі виводиться один документ для кожного з п’яти континентів, представлених у колекції. За замовчуванням етап групування не включає жодних додаткових полів з вихідного документа, оскільки він не знає, як і з якого документа отримати інші значення. Однак можна вказати кілька значень одного поля у виразі групування. Наступний приклад методу згрупує документи на основі значень у документах continent і country:\n\nРис. 19 – Приклад застусування $group\nНа далі, _id поле для виразу групування в цьому прикладі використовує вбудований документ, який, у свою чергу, містить два поля: одне для назви континенту та інше для назви країни. Обидва поля посилаються на поля з вихідних документів із використанням нотації шляху до поля зі знаком долара. Цього разу MongoDB повертає 14 результатів, оскільки в колекції є 14 різних пар країна-континент:\n\nРис. 19 – Приклад застусування $group\nЦі результати не впорядковані жодним значущим чином.", "type": "text", "meta": {"page": null, "order": 17, "ingested_at": "2025-11-09T22:28:27.224038"}}
{"id": "-304__________NO_SQL_docx#18", "doc_id": "-304__________NO_SQL_docx", "text": "тів, оскільки в колекції є 14 різних пар країна-континент:\n\nРис. 19 – Приклад застусування $group\nЦі результати не впорядковані жодним значущим чином. У міру того, як ви все більше й більше працюєте з даними, ви, ймовірно, зіткнетеся з ситуаціями, коли вам потрібно виконати більш складний аналіз даних. З цією метою MongoDB надає ряд операторів-акумуляторів, які дозволяють вам знаходити більш детальну інформацію про ваші дані. Оператор накопичувача, який іноді називають просто накопичувачем , — це особливий тип операції, яка зберігає своє значення або стан під час проходження через конвеєр агрегації, наприклад суму або середнє значення кількох значень. Для ілюстрації потрібно запустити наступний aggregate() метод. На етапі цього методу $group створюється необхідний _id вираз групування, а також три додаткові обчислювані поля. Усі ці обчислювані поля містять оператор накопичувача та його значення. Ось розбивка цих обчислюваних полів:\nhighest_population: це поле містить максимальне значення сукупності в групі. Оператор $max накопичувача обчислює максимальне значення для \"$population\" всіх документів у групі. first_city: містить назву першого міста в групі.", "type": "text", "meta": {"page": null, "order": 18, "ingested_at": "2025-11-09T22:28:27.224041"}}
{"id": "-304__________NO_SQL_docx#19", "doc_id": "-304__________NO_SQL_docx", "text": ". Оператор $max накопичувача обчислює максимальне значення для \"$population\" всіх документів у групі. first_city: містить назву першого міста в групі. Оператор $first накопичувача бере значення \"$name\" з першого документа, що з’являється в групі. Зауважте, що оскільки список документів тепер невпорядкований, це не робить його автоматично містом з найбільшою кількістю населення, а радше першим містом, яке MongoDB знаходить у кожній групі. cities_in_top_20: містить кількість міст у колекції для кожної пари континент-країна. Для цього використовується $sum оператор накопичувача для обчислення суми всіх пар у списку. У цьому прикладі сума приймає одиницю для кожного документа і не стосується певного поля у вихідному документі. Ви можете додати стільки додаткових обчислюваних полів, скільки потрібно для вашого випадку використання, але поки що виконайте цей приклад запиту:\n\nРис. 20 – Приклад застусування $group з використанням допоміжних операторів\nMongoDB повертає такі 14 документів, по одному для кожної унікальної групи, визначеної виразом групування:\n\nРис.", "type": "text", "meta": {"page": null, "order": 19, "ingested_at": "2025-11-09T22:28:27.224043"}}
{"id": "-304__________NO_SQL_docx#20", "doc_id": "-304__________NO_SQL_docx", "text": "з використанням допоміжних операторів\nMongoDB повертає такі 14 документів, по одному для кожної унікальної групи, визначеної виразом групування:\n\nРис. 21 – Приклад застусування $group з використанням допоміжних операторів\nІмена полів у повернених документах відповідають обчисленим іменам полів у документі етапу групування. Щоб детальніше розглянути результати, звузимо нашу увагу до одного документа:\n\nРис. 22 – Приклад застусування $group з використанням допоміжних операторів\nПоле _id містить значення виразу групування для Японії та Азії. У cities_in_top_20полі видно, що два японські міста входять до списку 20 найбільш густонаселених міст. Згадайте, що з кроку 1 ви додали лише два документи, які представляють міста Японії (Токіо та Осака), тому це значення є правильним. Відповідає highest_population населенню Токіо, яке справді є більшим із двох. Однак first_city показує Осаку, а не Токіо, як можна було очікувати. Це тому, що етап групування використовував список вихідних документів, які не були впорядковані за сукупністю, тому він не міг гарантувати логічне значення «першого» в цьому сценарії. Осака спочатку була оброблена конвеєром, тому з’являється в first_city значенні поля.", "type": "text", "meta": {"page": null, "order": 20, "ingested_at": "2025-11-09T22:28:27.224045"}}
{"id": "-304__________NO_SQL_docx#21", "doc_id": "-304__________NO_SQL_docx", "text": "не міг гарантувати логічне значення «першого» в цьому сценарії. Осака спочатку була оброблена конвеєром, тому з’являється в first_city значенні поля. П’ятий крок – Використання стадії $project агрегації\nПрацюючи з конвеєрами агрегації, вам іноді захочеться повернути лише кілька полів колекції документів або трохи змінити структуру, щоб перемістити деякі поля у вбудовані документи. Цю стратегію можна використовувати для редагування полів, які не слід включати у звіт, або для підготовки результатів у форматі, придатному для певних вимог програми. Скажімо, наприклад, якщо хочете отримати населення для кожного з міст у вибірці, але ви бажаєте, щоб результати мали такий формат:\n\nРис. 23 – Приклад застусування $project\n\nПоле location містить пару країни та континенту, назва міста та населення відображаються в полях name і population відповідно, а ідентифікатор документа _id не відображається у виведеному документі. Можна використовувати $project сцену для створення нових структур документів у конвеєрі агрегації, таким чином змінюючи спосіб відображення кінцевих документів у наборі результатів. Для ілюстрації запустіть наступний aggregate( )метод, який включає $project етап:\n\t\t\nРис.", "type": "text", "meta": {"page": null, "order": 21, "ingested_at": "2025-11-09T22:28:27.224048"}}
{"id": "-304__________NO_SQL_docx#22", "doc_id": "-304__________NO_SQL_docx", "text": "посіб відображення кінцевих документів у наборі результатів. Для ілюстрації запустіть наступний aggregate( )метод, який включає $project етап:\n\t\t\nРис. 24 – Приклад застусування $project\nЦінністю для цього $project етапу є проекційний документ, що описує вихідну структуру. Ці проекційні документи мають той самий формат, що й ті, що використовуються в запитах , побудовані як проекції включення або проекції виключення. Ключі проекційного документа відповідають ключам від вхідних документів, що надходять на $project етапу. Якщо документ проекції містить ключі зі 1значеннями, він описує список полів, які будуть включені в результат. З іншого боку, якщо для ключів проекції встановлено значення 0, документ проекції описує список полів, які буде виключено з результату. У конвеєрі агрегації прогнози також можуть включати додаткові обчислені поля. У таких випадках проекція автоматично стає проекцією включення, і лише _idполе можна придушити шляхом додавання \"_id\": 0до документа проекції. Обчислювані поля використовують нотацію шляху поля знака долара для своїх значень і можуть посилатися на значення з вхідних документів.", "type": "text", "meta": {"page": null, "order": 22, "ingested_at": "2025-11-09T22:28:27.224050"}}
{"id": "-304__________NO_SQL_docx#23", "doc_id": "-304__________NO_SQL_docx", "text": "ента проекції. Обчислювані поля використовують нотацію шляху поля знака долара для своїх значень і можуть посилатися на значення з вхідних документів. У цьому прикладі ідентифікатор документа пригнічено за допомогою \"_id\": 0, name і population є обчислюваними полями, які посилаються на поля name та population з вхідних документів відповідно. Поле location стає вбудованим документом із двома додатковими ключами: country і continent, які посилаються на поля з вхідних документів. Використовуючи цей етап проектування, MongoDB поверне такі документи:\n\nРис. 25 – Приклад застусування $project\nТепер кожен документ відповідає новому формату, трансформованому на етапі проектування. Складання всіх етапів разом\nТепер можна об’єднати всі етапи, які використовували на попередніх кроках, щоб сформувати повнофункціональний конвеєр агрегації, який фільтрує та перетворює документи. Припустімо, що постає завдання знайти найбільш густонаселене місто для кожної країни в Азії та Північній Америці та повернути його назву та кількість населення.", "type": "text", "meta": {"page": null, "order": 23, "ingested_at": "2025-11-09T22:28:27.224052"}}
{"id": "-304__________NO_SQL_docx#24", "doc_id": "-304__________NO_SQL_docx", "text": ", що постає завдання знайти найбільш густонаселене місто для кожної країни в Азії та Північній Америці та повернути його назву та кількість населення. Результати слід відсортувати за найбільшою чисельністю населення, спершу повертаючи країни з найбільшими містами, і вас цікавлять лише країни, де найбільше населення міста перетинає поріг у 20 мільйонів людей. Нарешті, структура документа, яку ви прагнете, має повторювати наступне:\n\nРис. 26 – Приклад застусування всіх попередніх кроків\nЩоб проілюструвати, як отримати набір даних, який задовольнятиме ці вимоги, цей крок описує, як побудувати відповідний конвеєр агрегації. Почніть із виконання наступного запиту, який фільтрує початкові документи, що надходять із cities колекції, тому набір результатів міститиме лише країни Азії та Північної Америки. Незважаючи на те, що пізніше можна було б звузити вибір документів, це оптимізує ефективність конвеєра. Зрештою, обмеження кількості документів, які потрібно обробити на ранній стадії, мінімізує обсяг обробки, необхідний на наступних етапах:\n\nРис.", "type": "text", "meta": {"page": null, "order": 24, "ingested_at": "2025-11-09T22:28:27.224057"}}
{"id": "-304__________NO_SQL_docx#25", "doc_id": "-304__________NO_SQL_docx", "text": "веєра. Зрештою, обмеження кількості документів, які потрібно обробити на ранній стадії, мінімізує обсяг обробки, необхідний на наступних етапах:\n\nРис. 27 – Приклад застусування всіх попередніх кроків\nНа цій стадії конвеєра $match буде знайдено лише міста в Північній Америці та Азії, а документи, що представляють ці міста, буде повернено в повній оригінальній структурі та в порядку за замовчуванням:\n\nРис. 28 – Приклад застусування всіх попередніх кроків\nВбудований документ цього зразка location нагадує _id значення виразу групування, оскільки містить country і поля, і continent поля. Назва міста з найбільшою кількістю населення та кількість населення вкладені як вбудований документ під most_populated_city полем. Це відрізняється від результатів групування, де всі обчислені поля є полями верхнього рівня. Щоб трансформувати результати відповідно до цієї структури, додайте $project етап до конвеєра:\n\nРис. 29 – Приклад застусування всіх попередніх кроків\nЦей $project етап спочатку так скажемо, пригнічує _idполе від появи у виводі. Потім створюється location поле як вкладений документ, що містить два поля: country і continent.", "type": "text", "meta": {"page": null, "order": 25, "ingested_at": "2025-11-09T22:28:27.224060"}}
{"id": "-304__________NO_SQL_docx#26", "doc_id": "-304__________NO_SQL_docx", "text": "ку так скажемо, пригнічує _idполе від появи у виводі. Потім створюється location поле як вкладений документ, що містить два поля: country і continent. Використовуючи знак долара, кожне з цих полів посилається на значення з вхідних документів. \"$_id. country\" отримує значення з country поля зсередини _id вбудованого документа введення та $_id. continent отримує значення з його continent поля. most_populated_city має подібну структуру, вкладені поля name і population всередині. Вони стосуються полів верхнього рівня first_city та highest_population, відповідно. Цей етап проектування фактично створює абсолютно нову структуру для результату, яка виглядає наступним чином:\n\nРис. 30 – Приклад застусування всіх попередніх кроків\nЦей результат відповідає всім вимогам, визначеним на початку цього кроку:\nВін містить у списках лише міста з Азії та Північної Америки;\nДля кожної пари країн і континентів вибирається одне місто, і це місто з найбільшою кількістю населення;\nВідобразиться назва вибраного міста та населення;\nМіста відсортовані від найбільш густонаселених до найменш населених;\nФормат виводу змінено відповідно до прикладу документа.", "type": "text", "meta": {"page": null, "order": 26, "ingested_at": "2025-11-09T22:28:27.224062"}}
{"id": "-304__________NO_SQL_docx#27", "doc_id": "-304__________NO_SQL_docx", "text": "аного міста та населення;\nМіста відсортовані від найбільш густонаселених до найменш населених;\nФормат виводу змінено відповідно до прикладу документа. ВИСНОВКИ\nУ даному рефераті, ми ознайомилися з конвеєрами агрегації, функцією MongoDB для багатоетапної обробки документів, включаючи фільтрацію, сортування, узагальнення та трансформацію. Ми використали оператори $match, $sort, $group, і $project агрегації один за одним і разом, щоб виконати приклад сценарію звітування, обробивши вхідні документи для представлення зведених даних. Також, ознайомилися з обчислювальними полями та операторами накопичувачів, щоб знаходити максимуми та суми з груп документів. Було наведено багато прикладів запитів з агрегацією та в сьомому розділі застосовано всі етапи одночасно в одному запиті. ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ\nAggregation Operations, 2022. [Електронний ресурс]. Доступно з: https://www. mongodb. com/docs/manual/aggregation/ Дата звернення: Листопад 30, 2022. MongoDB Aggregation Example - Write Complex queries using MongoDB, 2022. [Електронний ресурс]. Доступно з: https://gis- https://cloudnweb. dev/2019/11/mongodb-aggregation-example/. Дата звернення: Листопад 30, 2022.", "type": "text", "meta": {"page": null, "order": 27, "ingested_at": "2025-11-09T22:28:27.224064"}}
{"id": "-304__________NO_SQL_docx#28", "doc_id": "-304__________NO_SQL_docx", "text": ", 2022. [Електронний ресурс]. Доступно з: https://gis- https://cloudnweb. dev/2019/11/mongodb-aggregation-example/. Дата звернення: Листопад 30, 2022. Агрегація в MongoDB: зменшення сукупного трубопроводу та карти, 2022. [Електронний ресурс]. Доступно з:  https://uk. myservername. com/working-with-vbscript-adodb-connection-objects. Дата звернення: Грудень 3, 2022. How To Use Aggregations in MongoDB, 2022. [Електронний ресурс]. Доступно з: https://www. digitalocean. com/community/tutorials/how-to-use-aggregations-in-mongodb. Дата звернення: Грудень 3, 2022. MongoDB Atlas, 2022. [Електронний ресурс]. Доступно з:  https://www. mongodb. com/cloud/atlas/lp/try4? utm_source=google&utm_campaign=search_gs_pl_evergreen_atlas_general_prosp-brand_gic-null_emea-ua_ps-all_desktop_eng_lead&utm_term=mongo%20database&utm_medium=cpc_paid_search&utm_ad=p&utm_ad_campaign_id=2030069972&adgroup=77296615612&gclid=Cj0KCQiA7bucBhCeARIsAIOwr--iA6GvwWwRhgXB0V6_Lzf2A3FvObDwthE_iAnuXJyQuonisbZ2bekaAgkyEALw_wcB. Дата звернення: Грудень 7, 2022. ОРГАНІЗАЦІЯ БАЗ ДАНИХ NoSQL, 2022. [Електронний ресурс]. Доступно з: https://ir. kneu. edu. ua/bitstream/handle/2010/38129/pract_sytnik_22. pdf? sequence=1.", "type": "text", "meta": {"page": null, "order": 28, "ingested_at": "2025-11-09T22:28:27.224067"}}
{"id": "-304__________NO_SQL_docx#29", "doc_id": "-304__________NO_SQL_docx", "text": "ЗАЦІЯ БАЗ ДАНИХ NoSQL, 2022. [Електронний ресурс]. Доступно з: https://ir. kneu. edu. ua/bitstream/handle/2010/38129/pract_sytnik_22. pdf? sequence=1. Дата звернення: Грудень 7, 2022. Queries and aggregation, 2022. [Електронний ресурс]. Доступно з:  https://livebook. manning. com/book/mongodb-in-action/chapter-5/. Дата звернення: Грудень 7, 2022.", "type": "text", "meta": {"page": null, "order": 29, "ingested_at": "2025-11-09T22:28:27.224069"}}
